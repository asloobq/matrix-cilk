#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>

#define DEBUG 0 

#if !defined(DEBUG) || DEBUG == 0
#define LOG(...) do {} while(0);

#elif DEBUG == 1
#define LOG(format, ...) printf(format, ##__VA_ARGS__)
#endif 


enum FillType {NEGATIVE_ONE, RANDOM};

/*
	Part of matrix multiplication. Perfroms multiplcation for 'n' rows in the result matrix,
	where n = endRow - startRow
*/
cilk void matMultPartRow(const int **A, const int **B, int **C, const int size, const int startRow, const int endRow) {
	int i, j, k;
	for(i = startRow ; i <= endRow ; i++)
		for(j = 0; j < size; j++) {
			C[i][j] = 0;
			for(k = 0; k < size; k++) {
				C[i][j] += (A[i][k] * B[k][j]);
			}
		}
}

/*
	Matrix multiplication Splitter.
*/
cilk void matMultStaticSplit(const int **A, const int **B, int **C, const int size, int splits) {
	/*
		Assuming both are square matrices of same size.
	*/
	int remainder, splitSize;
	int i;
	int startRow, endRow, startCol, endCol;
	LOG("matMultStaticSplit\n");
	/*
		Size has to be Greater than number of splits.
	*/
	if( size < splits) {
		/* set both same */
		splits = size;
	}	
	remainder  = (size % splits);/* will be added to last spawn is non-zero*/
	splitSize = size / splits;
	startRow = 0;
	endRow = startRow + splitSize - 1;
	for(i = 1; i <= (splits-1); i++) {
		LOG("matMultStaticSplit startRow = %d, endRow = %d\n", startRow, endRow);
		spawn matMultPartRow(A, B, C, size, startRow, endRow);

		startRow += splitSize;
		endRow = startRow + splitSize - 1;
	}

	/* Handle last iteration separately */
	spawn matMultPartRow(A, B, C, size, startRow, endRow + remainder);
	sync;
}

/*
	Simple matrix multiplication sequential order.
*/
cilk void matMultSimple(const int **A, const int **B, int **C, const int rows, const int cols) {
	int i, j, k;
	for(i = 0 ; i < rows; i++)
		for(j = 0; j < cols; j++) {
			C[i][j] = 0;
			for(k = 0; k < cols; k++) {
				C[i][j] += (A[i][k] * B[k][j]);
			}
		}
}


/*
	Adds two matrices A and B and stores result in C.
	Can have different no of rows and columns.
*/
cilk void matAdd(const int **A, const int **B, int **C, const int rows, const int cols) {
	int i, j;
	for(i = 0; i < rows; i++) {
		for(j = 0; j < cols; j++) {
			C[i][j] = A[i][j] + B[i][j];
		}
	}
}  

/*
	Checks if current 'splitSize' is less then or equal to base size.
	If yes, then performs normal addition.
	If no, then splits the matrix in half and calls recursively.
*/
cilk void matAddParallel(const int **A, const int **B, int **C, const int splitSize, const int base) {

}

/*
	Splits two matrices A and B into 'splits' number of pieces
	statically, and adds them. Stores result in matrix C.
	Handles case when 'size' is not a multiple of 'splits'.
	Adds all pieces in parallel.
*/
cilk void matSplitAdd(const int **A, const int **B, int **C, const int size,
	const int splits) {
	int i, offset;
	/* check if we can split equally */
	const int remainder = size % splits;
	const int splitSize  = size / splits;
	for( i = 0; i <= (splits-2); i++) {
		offset = i*splitSize;
		spawn matAdd(A + offset, B + offset, C + offset, splitSize, size); 
	}
	/* Handle last iteration separately to handle remaining rows */
	offset = i * splitSize;
	spawn matAdd(A + offset, B + offset, C + offset, splitSize + remainder, size);
	sync;
}

/*
	Prints a square matrix of size 'size'
*/
void printMat(const int **mat, const int size) {
	int i, j;
	printf("\n");
	for(i = 0; i < size; i++) {
		for(j =0; j < size; j++) {
			printf("%d ", mat[i][j]);
		}
		printf("\n");
	}
}

/*
	Initializes a matrix with some initial values.
	Initial value depends on enum type -
	Random : fills with random numbers.
	Negative_one : fills with -1
*/
cilk void initializeMat(int **mat, const int size, int fillType) {
	int i, j, seed;
	seed = size;
	LOG("initialize mat\n");
	LOG("Initialize mat size = %d\n", size);
	for(i = 0; i < size; i++) {
		LOG("initialize mat i = %d \n", i);
		for(j = 0; j < size; j++) {
			LOG("initialize mat j = %d : %d\n", j, size);
			if(fillType == RANDOM) {
				//mat[i][j] = rand_r(&seed);
				mat[i][j] = 2;
				seed = mat[i][j];
			} else {
				mat[i][j] = -1;
			}
		}
	}
} 

/*
	Initialises all three matrices with some initial values.
*/
cilk void initializeMats(int **A, int **B, int **C, const int size) {
	/*
	a. Load arrays A, B with positive random integers of any range 
	b. Load result array C with -1
	c. The loading of A, B, and C must be performed in parallel. 
	*/
	LOG("InitializeMats size : %d\n", size);
	spawn initializeMat(A, size, RANDOM);
	spawn initializeMat(B, size, RANDOM);
	spawn initializeMat(C, size, NEGATIVE_ONE);
	sync;
}

/*
	Allocates memory for a square matrix based on its size.
	@return pointer to the matrix.
*/
cilk int** createMat(int **mat, const int size) {
	int i;
	if((mat = (int**) malloc(size * sizeof(int*))) == NULL) {
		printf("Malloc error\n");
	}
	LOG("\n createMat \n");
        for(i = 0; i < size; i++) {
                if ((mat[i] = (int *)malloc(size * sizeof(int))) == NULL) {
			printf(" malloc error\n");
		}
		LOG("createmat %d \n", i);
        }
	LOG("creating mat\n");
	/*//Simpler way of malloc?
	mat = malloc(sizeof(sizeof(int) * size * size));
	if(mat == NULL) {
		printf("malloc error \n");
	}*/
	return mat;
}

/*
	Releases memory allocated by the three matrices.
*/
void matRelease(int **A, int **B, int **C) {
        free(A);
        free(B);
        free(C);
}

/*
	Perform all steps in Matrix Addition without
	Recursive Divide and Conquer.
*/
cilk void matAddStatic(const int workers, const int splits, const int size) {

	int **A, **B, **C;
	LOG("matAddStatic\n");
	//spawn createMats(A, B, C, size, splits);
	//sync;
	/*
		a. Initialize all matrices i.e. allocate memory space for matrices A, B, C
		b. Perform initializing concurrently i.e. parallel using Cilk constructs	
	*/
	//A
	LOG("creating mat A");
	A = spawn createMat(A, size);
	//B
	LOG("creating mat B");
	B = spawn createMat(B, size);
	//C
	LOG("creating mat C");
	C = spawn createMat(C, size);
	sync;
	
	spawn initializeMats(A, B, C, size);
	sync;	
	LOG("init finish\n");

	
	LOG("Printing A\n");
	printMat(A, size);
	LOG("Printing B\n");
	printMat(B, size);
	LOG("Printing C\n");
	printMat(C, size);
	LOG("Matrix Split Add \n");
	
//	spawn matSplitAdd(A, B, C, size, splits);
//	spawn matMultSimple(A, B, C, size, size);
	spawn matMultStaticSplit(A, B, C, size, splits);
	sync;
	LOG("Printing C\n");
	printMat(C, size);
	LOG("Releasing matrices \n");
	matRelease(A, B, C);
}

cilk int main(int argc, char *argv[]) {
	/* parse arguments */
	/* example ./madd --nproc 2 5 500 
	workers = 2
	splits = 5
	size = 500
	*/
	int workers, splits, size;
	/* parse using atoi*/
	if(argc == 3) {
		workers = atoi(argv[0]);
		splits = atoi(argv[1]);
		size = atoi(argv[2]);
		spawn matAddStatic(workers, splits, size);
		sync;
		LOG("Hello World workers = %d, splits = %d, size = %d\n", 
			workers, splits, size);
	} else {
		LOG("argc = %d\n", argc);
		printf("usage --nproc <workers> <splits> <size>\n");
		return 0;
	}
	return 0;
}
