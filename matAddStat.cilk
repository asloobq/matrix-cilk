#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>


cilk void matAdd(const int **A, const int **B, int **C, const int rows, const int cols) {
	int i, j;
	for(i = 0; i < rows; i++) {
		for(j = 0; j < cols; j++) {
			C[i][j] = A[i][j] + B[i][j];
		}
	}
}  

cilk void matSplitAdd(const int **A, const int **B, int **C, const int size,
	const int splits) {
	int i, offset;
	/* check if we can split equally */
	const int remainder = size % splits;
	const int splitSize  = size / splits;
	for( i = 0; i <= (splits-2); i++) {
		offset = i*splitSize;
		spawn matAdd(A + offset, B + offset, C + offset, splitSize, size); 
	}
	offset = i * splitSize;
	spawn matAdd(A + offset, B + offset, C + offset, splitSize + remainder, size);
	sync;
}

void printMat(const int **mat, const int size) {
	int i, j;
	printf("\n");
	for(i = 0; i < size; i++) {
		for(j =0; j < size; j++) {
			printf("%d ", mat[i][j]);
		}
		printf("\n");
	}
}

cilk void initializeMat(int **mat, const int size, const int initval) {
	int i, j;
	printf("initialize mat\n");
	printf("Initialize mat size = %d\n", size);
	for(i = 0; i < size; i++) {
		printf("initialize mat i = %d \n", i);
		for(j = 0; j < size; j++) {
			printf("initialize mat j = %d : %d\n", j, size);
			//if(initval == 0) {
			//	mat[i][j] = rand_r(&size);
			//} else {
				mat[i][j] = initval;
			//}
		}
	}
} 

cilk void initializeMats(int **A, int **B, int **C, const int size) {
	/*
	a. Load arrays A, B with positive random integers of any range 
b. Load result array C with -1
c. The loading of A, B, and C must be performed in parallel. 
	*/
	printf("size : %d\n", size);
	 spawn initializeMat(A, size, 1);
	 spawn initializeMat(B, size, 1);
	 spawn initializeMat(C, size, -1);
	sync;
}

cilk int** createMat(int **mat, const int size) {
	int i, j;
	if((mat = (int**) malloc(size * sizeof(int*))) == NULL) {
		printf("Malloc error\n");
	}
	printf("\n createMat \n");
        for(i = 0; i < size; i++) {
                if ((mat[i] = (int *)malloc(size * sizeof(int))) == NULL) {
			printf(" malloc error\n");
		}
		printf("createmat %d \n", i);
		mat[i][0] = 0;
		printf("m = %d", mat[i][0]);
        }
	printf("creating mat\n");
	/*mat = malloc(sizeof(sizeof(int) * size * size));
	if(mat == NULL) {
		printf("malloc error \n");
	}*/
}

void matRelease(int **A, int **B, int **C) {
        free(A);
        free(B);
        free(C);
}

cilk void createMats(int **A, int **B, int **C, const int size, const int splits) {
	/*
	a. Initialize all matrices i.e. allocate memory space for matrices A, B, C
	b. Perform initializing concurrently i.e. parallel using Cilk constructs	
	*/
	//A
	printf("creating mat A");
	A = spawn createMat(A, size);
	//B
	printf("creating mat B");
	B = spawn createMat(B, size);
	//C
	printf("creating mat C");
	C = spawn createMat(C, size);
	sync;
	
	spawn initializeMats(A, B, C, size);
	sync;	
	printf("init finish\n");

	
	printf("Printing A\n");
	printMat(A, size);
	printf("Printing B\n");
	printMat(B, size);
	printf("Printing C\n");
	printMat(C, size);
	printf("Matrix Split Add \n");
	
	spawn matSplitAdd(A, B, C, size, splits);
	printf("Printing C\n");
	printMat(C, size);
	printf("Releasing matrices \n");
	matRelease(A, B, C);
}


cilk void matAddStatic(const int workers, const int splits, const int size) {

	int **A, **B, **C;
	printf("matAddStatic\n");
	spawn createMats(A, B, C, size, splits);
	sync;
}

cilk int main(int argc, char *argv[]) {
	/* parse arguments */
	/* example ./madd --nproc 2 5 500 
	workers = 2
	splits = 5
	size = 500
	*/
	int workers, splits, size;
	/* parse using atoi*/
	if(argc == 3) {
		workers = atoi(argv[0]);
		splits = atoi(argv[1]);
		size = atoi(argv[2]);
		spawn matAddStatic(workers, splits, size);
		sync;
		printf("Hello World workers = %d, splits = %d, size = %d\n", 
			workers, splits, size);
	} else {
		printf("argc = %d\n", argc);
		printf("usage --nproc <workers> <splits> <size>\n");
		return 0;
	}
	return 0;
}
